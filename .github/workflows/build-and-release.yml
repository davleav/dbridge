name: Build and Release AppImage

on:
  push:
    tags:
      - 'v*'  # Run workflow on version tags, e.g. v0.8.1
  workflow_dispatch:  # Allow manual triggering

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
          
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then
            pip install -r requirements.txt
          else
            pip install PyQt6 SQLAlchemy pymysql psycopg2-binary pandas matplotlib pyinstaller
          fi
          
      - name: Extract version from tag
        id: get_version
        run: |
          echo "GITHUB_REF is: $GITHUB_REF"
          echo "GITHUB_SHA is: $GITHUB_SHA"
          
          if [[ $GITHUB_REF == refs/tags/v* ]]; then
            echo "This is a tag-based build"
            VERSION=${GITHUB_REF#refs/tags/v}
          else
            echo "This is a manual or branch-based build"
            VERSION="dev-$(date +'%Y%m%d')"
          fi
          
          echo "Setting VERSION to: $VERSION"
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          
          # Verify the environment variable was set
          echo "Verifying VERSION environment variable: $VERSION"
          
      - name: Build AppImage
        run: |
          # Clean up any previous build artifacts
          rm -rf venv AppDir dist build *.AppImage resources/icon.png
          mkdir -p resources
          
          # Copy the icon
          cp DBridge.png resources/icon.png
          
          # Create AppDir structure
          mkdir -p AppDir/usr/bin
          mkdir -p AppDir/usr/share/applications
          mkdir -p AppDir/usr/share/icons/hicolor/256x256/apps
          
          # Copy icon to AppDir
          cp resources/icon.png AppDir/usr/share/icons/hicolor/256x256/apps/dbridge.png
          cp resources/icon.png AppDir/dbridge.png
          
          # Create desktop file with version
          echo "[Desktop Entry]
          Version=1.0
          Type=Application
          Name=DBridge
          Comment=A user-friendly SQL client (v${VERSION})
          Exec=dbridge
          Icon=dbridge
          Categories=Development;Database;
          Terminal=false
          StartupNotify=true" > AppDir/usr/share/applications/dbridge.desktop
          
          # Copy desktop file to root of AppDir
          cp AppDir/usr/share/applications/dbridge.desktop AppDir/dbridge.desktop
          
          # Set permissions
          chmod 755 AppDir/dbridge.desktop
          chmod 755 AppDir/usr/share/applications/dbridge.desktop
          
          # Create AppRun script
          cat > AppDir/AppRun << 'APPRUNEOF'
          #!/bin/bash
          SELF=$(readlink -f "$0")
          HERE=${SELF%/*}
          export PATH="${HERE}/usr/bin:${PATH}"
          export PYTHONPATH="${HERE}/usr/lib/python3.10/site-packages:${PYTHONPATH}"
          exec "${HERE}/usr/bin/dbridge" "$@"
          APPRUNEOF
          chmod +x AppDir/AppRun
          
          # Create launcher script
          cat > AppDir/usr/bin/dbridge << 'LAUNCHEREOF'
          #!/bin/bash
          python -m src.main
          LAUNCHEREOF
          chmod +x AppDir/usr/bin/dbridge
          
          # Use PyInstaller to bundle the application
          echo "Looking for main.py..."
          find . -name "main.py" | sort
          
          if [ -f src/main.py ]; then
            echo "Found src/main.py, using it for PyInstaller"
            pyinstaller --onedir --name dbridge src/main.py
          else
            echo "src/main.py not found, searching for alternatives..."
            MAIN_PY=$(find . -name "main.py" | head -1)
            if [ -n "$MAIN_PY" ]; then
              echo "Found alternative main.py at: $MAIN_PY"
              pyinstaller --onedir --name dbridge "$MAIN_PY"
            else
              echo "Error: No main.py found. Cannot continue."
              echo "Current directory structure:"
              find . -type f -name "*.py" | sort
              exit 1
            fi
          fi
          
          # Verify PyInstaller output
          echo "Checking PyInstaller output:"
          if [ -d "dist/dbridge" ]; then
            echo "PyInstaller output exists at dist/dbridge"
            ls -la dist/dbridge
          else
            echo "ERROR: PyInstaller output not found!"
            echo "Contents of dist directory (if it exists):"
            ls -la dist || echo "dist directory does not exist"
            exit 1
          fi
          
          # Copy the bundled application to AppDir
          cp -r dist/dbridge/* AppDir/usr/bin/
          
          # Verify AppDir structure before running AppImageTool
          echo "Verifying AppDir structure..."
          echo "Contents of AppDir:"
          find AppDir -type f | sort
          
          echo "Checking for desktop file:"
          ls -la AppDir/*.desktop AppDir/usr/share/applications/*.desktop || echo "Desktop files not found!"
          
          echo "Checking for icon file:"
          ls -la AppDir/*.png AppDir/usr/share/icons/hicolor/256x256/apps/*.png || echo "Icon files not found!"
          
          echo "Checking for AppRun and executable:"
          ls -la AppDir/AppRun || echo "AppRun not found!"
          ls -la AppDir/usr/bin/dbridge || echo "dbridge executable not found!"
          
          echo "Checking AppDir structure is complete for AppImage creation:"
          if [ -f "AppDir/AppRun" ] && [ -f "AppDir/usr/bin/dbridge" ] && [ -f "AppDir/usr/share/applications/dbridge.desktop" ] && [ -f "AppDir/usr/share/icons/hicolor/256x256/apps/dbridge.png" ]; then
            echo "AppDir structure looks correct"
          else
            echo "WARNING: AppDir structure may be incomplete!"
          fi
          
          # Download appimagetool
          wget -c "https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage"
          chmod +x appimagetool-x86_64.AppImage
          
          # Install FUSE
          sudo apt-get update
          sudo apt-get install -y libfuse2
          
          # Try to run appimagetool directly, if it fails, use the extracted version
          echo "Trying to run AppImageTool directly..."
          APPIMAGE_FILENAME="DBridge-${VERSION}-x86_64.AppImage"
          echo "AppImage filename will be: $APPIMAGE_FILENAME"
          
          if ! ARCH=x86_64 ./appimagetool-x86_64.AppImage AppDir "$APPIMAGE_FILENAME"; then
            echo "Direct execution failed, extracting AppImageTool..."
            ./appimagetool-x86_64.AppImage --appimage-extract
            echo "Running extracted AppImageTool..."
            ARCH=x86_64 ./squashfs-root/AppRun AppDir "$APPIMAGE_FILENAME"
          fi
          
          # Check if AppImage was created
          if [ -f "$APPIMAGE_FILENAME" ]; then
            echo "AppImage created successfully: $APPIMAGE_FILENAME"
            # Ensure the AppImage is executable
            chmod +x "$APPIMAGE_FILENAME"
            # List directory contents to verify
            ls -la
            
            # Check file type and size
            echo "AppImage file type: $(file "$APPIMAGE_FILENAME")"
            echo "AppImage file size: $(du -h "$APPIMAGE_FILENAME" | cut -f1)"
            
            # Try to run the AppImage with --appimage-extract-and-run to verify it's valid
            echo "Attempting to verify AppImage validity..."
            if ./"$APPIMAGE_FILENAME" --appimage-offset > /dev/null 2>&1; then
              echo "AppImage appears to be valid (has AppImage offset)"
            else
              echo "WARNING: AppImage may not be valid (no AppImage offset found)"
              # Don't exit with error yet, we'll still try to upload it
            fi
          else
            echo "ERROR: AppImage was not created!"
            echo "Current directory contents:"
            ls -la
            exit 1
          fi
          
      # Save the AppImage filename as an output
      - name: Set AppImage filename as output
        id: appimage_filename
        run: |
          echo "Current VERSION is: $VERSION"
          APPIMAGE_FILENAME="DBridge-${VERSION}-x86_64.AppImage"
          echo "APPIMAGE_FILENAME=$APPIMAGE_FILENAME" >> $GITHUB_ENV
          echo "filename=$APPIMAGE_FILENAME" >> $GITHUB_OUTPUT
          echo "AppImage filename: $APPIMAGE_FILENAME"
          
          # List all files in the current directory
          echo "All files in current directory:"
          ls -la
          
          # Check for any AppImage files
          echo "Looking for any AppImage files:"
          find . -name "*.AppImage" -type f
          
          # Verify file exists again
          if [ -f "$APPIMAGE_FILENAME" ]; then
            echo "File exists and will be uploaded"
            ls -la "$APPIMAGE_FILENAME"
            echo "File size: $(du -h "$APPIMAGE_FILENAME" | cut -f1)"
            echo "File type: $(file "$APPIMAGE_FILENAME")"
          else
            echo "ERROR: Expected AppImage file does not exist!"
            echo "Looking for any files that might be the AppImage with a different name:"
            find . -type f -size +1M | xargs ls -lh
            exit 1
          fi

      - name: Upload AppImage as artifact
        uses: actions/upload-artifact@v4
        with:
          name: linux-appimage
          path: ${{ env.APPIMAGE_FILENAME }}

      - name: Debug Release Info
        run: |
          echo "github.ref: ${{ github.ref }}"
          echo "startsWith check: ${{ startsWith(github.ref, 'refs/tags/') }}"
          echo "VERSION: ${{ env.VERSION }}"
          echo "APPIMAGE_FILENAME: ${{ env.APPIMAGE_FILENAME }}"
          echo "File exists check: $([ -f "${{ env.APPIMAGE_FILENAME }}" ] && echo 'Yes' || echo 'No')"

      - name: Create Release (Tag-based)
        id: create_release_tag
        uses: softprops/action-gh-release@v1
        if: startsWith(github.ref, 'refs/tags/')
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          files: ${{ env.APPIMAGE_FILENAME }}
          name: DBridge v${{ env.VERSION }}
          draft: false
          prerelease: false
          generate_release_notes: true
          
      - name: Create Release (Manual Trigger)
        id: create_release_manual
        uses: softprops/action-gh-release@v1
        if: github.event_name == 'workflow_dispatch'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          files: ${{ env.APPIMAGE_FILENAME }}
          name: DBridge v${{ env.VERSION }} (Development Build)
          tag_name: dev-${{ github.run_number }}
          draft: true
          prerelease: true
          generate_release_notes: false
          body: |
            # Development Build
            
            This is a development build created from the ${{ github.ref_name }} branch.
            Build number: ${{ github.run_number }}
            Commit: ${{ github.sha }}
            
            This release is automatically generated from a manual workflow trigger.